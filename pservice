#!/usr/bin/env python3

import argparse
import http.server
import os
import re
import sqlite3
import ssl
import sys
import unittest

from base64 import b64decode
from binascii import hexlify

KEY_LENGTH_IN_BYTES = int(256 / 8)

STORAGE_V1_RX = re.compile(r'^/storage/v1/([\da-fA-F]{%d})$' % int(KEY_LENGTH_IN_BYTES * 2))
STORAGE_V1_RX_KEY_IDX = 1

class TestVectors:
	class Storage:
		# Values only known to the P-Lib
		KeyPlaintext   = b64decode(b'TXkgUElO') # "My PIN"
		ValuePlaintext = b64decode(b'MTIzNA==') # "1234"
		SecretKey      = b64decode(b'SfB36Uo9HfuEh6OMqQtON3WzSyy/1/N+IZe7zZOOuiw=')
		HashKey        = b64decode(b'y7QsdX+kOcDlup9KpVREZepSDUiqsaY/6Zb3ovmLvuQ=')

		# Values known to the P-Service (and P-Lib)
		Nonce      = b64decode(b'IdW1+TjJj3KaW79XN1FaFRJoU2Y5T79I')
		Mac        = b64decode(b'kI7zi/vGkh25lFRU2Of+/w==')
		Ciphertext = b64decode(b'aYpHnw==') # E("1234", SecretKey, Nonce)

		# Values actually stored by the P-Service
		Key   = b64decode(b'/LZHGWGCnSgnBGKi1cun/RQdgMYI1t8HT44uITwYdHE=') # H("My PIN", Salt)
		Value = b64decode(b'IdW1+TjJj3KaW79XN1FaFRJoU2Y5T79IkI7zi/vGkh25lFRU2Of+/2mKR58=') # Nonce + Mac + Ciphertext

class HttpHeader:
	Host = 'Host'
	ContentLength = 'Content-Length'
	ContentType = 'Content-Type'

class HttpStatus:
	Ok = 200
	BadRequest = 400
	NotFound = 404

def HttpStatusString(code: int) -> str:
	return {
		200: 'Ok',
		400: 'Bad Request',
		404: 'Not Found',
	}.get(code, None)

class MimeType:
	class Application:
		OctetStream = 'application/octet-stream'

def fatal(message: str, exitCode: int = 1):
	print(message, file = sys.stderr)
	exit(exitCode)

def open_db():
	db = sqlite3.connect('data.db')
	cursor = db.cursor()
	cursor.execute('''
		CREATE TABLE IF NOT EXISTS Storage (
			Key VARCHAR(%d) PRIMARY KEY,
			Value BLOB
		) WITHOUT ROWID;
	''' % int(KEY_LENGTH_IN_BYTES * 2))
	db.commit()
	return db

def insert_or_replace_key_value(key: bin, value: bin):
	db = open_db()
	cursor = db.cursor()
	cursor.execute('''
		INSERT OR REPLACE INTO Storage (Key, Value) VALUES (?, ?);
	''', (key, value))
	db.commit()
	db.close()

class Settings:
	AllowSuperfluousHeaders = False

class PServiceRequestHandler(http.server.BaseHTTPRequestHandler):

	def sanitize_request_headers(self, allowed_headers):
		if not Settings.AllowSuperfluousHeaders:
			superfluous_headers = set(self.headers) - allowed_headers
			if superfluous_headers:
				self.send_error(
					HttpStatus.BadRequest,
					message = HttpStatusString(HttpStatus.BadRequest),
					explain = 'Superfluous headers are not allowed, they could be used for fingerprinting attacks: "%s"' %
						'", "'.join(sorted(list(superfluous_headers))),
				)
				return False
		return True

	def do_GET(self):
		m = STORAGE_V1_RX.match(self.path)
		if m:
			if not self.sanitize_request_headers({HttpHeader.Host}):
				return
			key = str(m.group(STORAGE_V1_RX_KEY_IDX))
			db = open_db()
			cursor = db.cursor()
			cursor.execute('''
				SELECT Value FROM Storage WHERE Key = ?;
			''', (key,))
			row = cursor.fetchone()
			db.close()
			if row:
				value = row[0]
				self.send_response(HttpStatus.Ok)
				self.send_header(HttpHeader.ContentType, MimeType.Application.OctetStream)
				self.end_headers()
				self.wfile.write(value)
			else:
				self.send_error(
					HttpStatus.NotFound,
					message = HttpStatusString(HttpStatus.NotFound),
					explain = 'The requested entry does not exist.'
				)
		else:
			self.send_error(
				HttpStatus.NotFound,
				message = HttpStatusString(HttpStatus.NotFound),
				explain = 'The URL is not a valid service endpoint.'
			)

	def do_POST(self):
		m = STORAGE_V1_RX.match(self.path)
		if m:
			if not self.sanitize_request_headers({
				HttpHeader.Host,
				HttpHeader.ContentType,
				HttpHeader.ContentLength,
			}):
				return
			key = m.group(STORAGE_V1_RX_KEY_IDX)
			try:
				contentLength = int(self.headers[HttpHeader.ContentLength])
			except ValueError:
				self.send_error(
					HttpStatus.BadRequest,
					message = HttpStatusString(HttpStatus.BadRequest),
					explain = '"%s" is not a valid value for the HTTP "%s" header.' % (
						self.headers[HttpHeader.ContentLength],
						HttpHeader.ContentLength
					)
				)
				return
			value = self.rfile.read(contentLength)
			insert_or_replace_key_value(key, value)
			self.send_response(HttpStatus.Ok)
			self.end_headers()
		else:
			self.send_error(
				HttpStatus.NotFound,
				message = HttpStatusString(HttpStatus.NotFound),
				explain = 'The URL is not a valid service endpoint.'
			)

def main():
	binpath = os.path.split(sys.argv[0])[0]
	keyfile = os.path.join(binpath, 'key.pem')
	crtfile = os.path.join(binpath, 'crt.pem')

	parser = argparse.ArgumentParser()
	parser.add_argument(
		'-t', '--test',
		help = 'Run unit tests. Additional arguments are available. If this option is set, it has to be the first.',
		action = 'store_true',
		default = False,
	)
	parser.add_argument(
		'-p', '--port',
		help = 'The port the server should listen on.',
		type = int,
		default = 8080,
	)
	parser.add_argument(
		'-a', '--address',
		help = 'The address the server should listen on.',
		type = str,
		default = '',
	)
	parser.add_argument(
		'-k', '--keyfile',
		help = 'The file containing the private key for SSL connections in PEM format.',
		type = str,
		default = keyfile,
	)
	parser.add_argument(
		'-c', '--certfile',
		help = 'The file containing the certificate for SSL connections in PEM format.',
		type = str,
		default = crtfile,
	)
	parser.add_argument(
		'--allow-superfluous-headers',
		help = 'When set additional HTTP headers will be ignored. A request with additional headers will be rejected else.',
		action = 'store_true',
		default = Settings.AllowSuperfluousHeaders,
	)
	args = parser.parse_args()

	if args.test:
		parser.print_help()
		exit(1)

	keyfile = args.keyfile
	crtfile = args.certfile

	serverAddress = (args.address, args.port)

	Settings.AllowSuperfluousHeaders = args.allow_superfluous_headers

	if not os.path.isfile(keyfile):
		fatal('Missing file: %s' % keyfile)
	if not os.path.isfile(crtfile):
		fatal('Missing file: %s' % crtfile)

	# Insert test vectors
	insert_or_replace_key_value(
		key   = str(hexlify(TestVectors.Storage.Key), encoding = 'ascii'),
		value = TestVectors.Storage.Value
	)

	try:
		httpd = http.server.HTTPServer(serverAddress, PServiceRequestHandler)
	except PermissionError:
		fatal('Permission denied. Maybe you need root access to open port %d?' % serverAddress[1])

	context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
	context.options |= ssl.OP_NO_SSLv2
	context.options |= ssl.OP_NO_SSLv3
	context.options |= ssl.OP_NO_TLSv1
	context.options |= ssl.OP_NO_TLSv1_1
	context.load_cert_chain(
		certfile = crtfile,
		keyfile  = keyfile,
	)

	httpd.socket = context.wrap_socket(
		httpd.socket,
		server_side = True,
	)
	print('Listening on port %d... press ^C to quit.' % serverAddress[1])
	try:
		httpd.serve_forever()
	except KeyboardInterrupt:
		httpd.shutdown()
	print('Done.')

class TestRegularExpressions(unittest.TestCase):

	def test_storage_v1_rx(self):
		# Positive test
		m = STORAGE_V1_RX.match('/storage/v1/ed5d0909f2c385b92166ae74aa6945cdd4d01c3b746ff7c90b93c5725078fc76')
		self.assertIsNotNone(m)
		self.assertEqual(
			m.group(STORAGE_V1_RX_KEY_IDX),
			'ed5d0909f2c385b92166ae74aa6945cdd4d01c3b746ff7c90b93c5725078fc76'
		)

		# Negative tests
		self.assertIsNone(STORAGE_V1_RX.match('/storage/v1/ed5d0909f2c385b92166ae74aa6945cdd4d01c3b746ff7c90b9'))
		self.assertIsNone(STORAGE_V1_RX.match('/storage/v1/ed5d0909f2c385b92166ae74aa6945cdd4d01c3b746ff7c90b93c'))
		self.assertIsNone(STORAGE_V1_RX.match('/storage/v1/ed5d0909f2c385b92166ae74aa6945cdd4d01c3b746ff7c90b9x'))
		self.assertIsNone(STORAGE_V1_RX.match('/storage/v2/ed5d0909f2c385b92166ae74aa6945cdd4d01c3b746ff7c90b93'))
		self.assertIsNone(STORAGE_V1_RX.match('/storaage/v1/ed5d0909f2c385b92166ae74aa6945cdd4d01c3b746ff7c90b93'))

if __name__ == '__main__':
	if len(sys.argv) > 1 and sys.argv[1] in ['-t', '--test']:
		del sys.argv[1]
		unittest.main()
	else:
		main()
