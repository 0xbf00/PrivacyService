#!/usr/bin/env python3

import argparse
import http.server
import json
import os
import re
import sqlite3
import ssl
import sys
import tempfile
import unittest
import uuid

from base64 import b64decode
from binascii import hexlify
from http import HTTPStatus

KEY_LENGTH_IN_BYTES = int(256 / 8)

STORAGE_V1_RX = re.compile(r'^/storage/v1/([\da-fA-F]{%d})$' % int(KEY_LENGTH_IN_BYTES * 2))
STORAGE_V1_RX_KEY_IDX = 1

def fatal(message: str, exitCode: int = 1):
	print(message, file = sys.stderr)
	exit(exitCode)

class HttpHeader:
	Host = 'Host'
	ContentLength = 'Content-Length'
	ContentType = 'Content-Type'

class MimeType:
	class Application:
		OctetStream = 'application/octet-stream'

class Database:

	def __init__(self, file_name):
		self.db = sqlite3.connect(file_name)
		self.test_vectors = dict()
		
		# Initialize database schema
		cursor = self.db.cursor()
		cursor.execute('''
			CREATE TABLE IF NOT EXISTS Storage (
				Key VARCHAR(%d) PRIMARY KEY,
				Value BLOB
			) WITHOUT ROWID;
		''' % int(KEY_LENGTH_IN_BYTES * 2))
		self.db.commit()

	def __del__(self):
		self.db.close()

	def load_test_vectors(self, file_name):
		with open(file_name, 'r') as f:
			j = json.load(f)

		result = dict()

		for project in j.keys():
			print("Importing test vectors for '%s'..." % project)
			casenum = 0
			for case in j[project]:
				casenum += 1

				print("  Case %d:" % casenum)
				if case['type'] == 'storage':

					entries = case['entries']
					for entry in entries:
						bkey = b64decode(entry['key']['ciphertext'])
						key = str(hexlify(bkey), encoding = 'ascii')
						value = b64decode(entry['value']['ciphertext'])
						pkey = entry['key']['plaintext']

						m = STORAGE_V1_RX.match('/storage/v1/' + key)
						if not m:
							fatal("    Invalid key: '%s'" % key)

						result[key] = value
						print("    Added '%s' to 'storage/v1' ('%s')." % (key, pkey))

		self.test_vectors = result

	def insert_or_replace(self, key, value):
		# Check if the given `key` is a test vector
		if key in self.test_vectors:
			self.test_vectors[key] = value
			return

		# Use the actual database if the given `key` is not a test vector
		cursor = self.db.cursor()
		cursor.execute(
			'INSERT OR REPLACE INTO Storage (Key, Value) VALUES (?, ?);',
			(key, value)
		)
		self.db.commit()

	def value_for(self, key):
		# Check if the given `key` is a test vector
		if key in self.test_vectors:
			return self.test_vectors[key]

		# Use the actual database if the given `key` is not a test vector
		cursor = self.db.cursor()
		cursor.execute('SELECT Value FROM Storage WHERE Key = ?;', (key,))
		row = cursor.fetchone()
		if row:
			return row[0]

		return None

	def remove(self, key):
		# Check if the given `key` is a test vector
		if key in self.test_vectors:
			del self.test_vectors[key]
			return

		# Use the actual database if the given `key` is not a test vector
		cursor = self.db.cursor()
		cursor.execute('DELETE FROM Storage WHERE Key = ?;', (key,))
		self.db.commit()

class PServiceRequestHandler(http.server.BaseHTTPRequestHandler):

	def sanitize_request_headers(self, allowed_headers):
		if not self.server.allow_superfluous_headers:
			superfluous_headers = set(self.headers) - allowed_headers
			if superfluous_headers:
				self.send_error(
					HTTPStatus.BAD_REQUEST,
					message = HTTPStatus.BAD_REQUEST.phrase,
					explain = 'Superfluous headers are not allowed, they could be used for fingerprinting attacks: "%s"' %
						'", "'.join(sorted(list(superfluous_headers))),
				)
				return False
		return True

	def parse_storage_key(self):
		m = STORAGE_V1_RX.match(self.path)
		
		if not m:
			self.send_error(
				HTTPStatus.NOT_FOUND,
				message = HTTPStatus.NOT_FOUND.phrase,
				explain = 'The URL is not a valid service endpoint.'
			)
			return None

		return str(m.group(STORAGE_V1_RX_KEY_IDX))

	def send_ok(self, headers = None, body = None):
		self.send_response(HTTPStatus.OK)

		if headers:
			for key in headers.keys():
				self.send_header(key, headers[key])

		self.end_headers()

		if body:
			self.wfile.write(body)

	def do_GET(self):
		key = self.parse_storage_key()
		if not key:
			return

		if not self.sanitize_request_headers({HttpHeader.Host}):
			return

		value = self.server.db.value_for(key)
		if not value:
			self.send_error(
				HTTPStatus.NOT_FOUND,
				message = HTTPStatus.NOT_FOUND.phrase,
				explain = 'The requested entry does not exist.'
			)

		self.send_ok(
			headers = {
				HttpHeader.ContentType: MimeType.Application.OctetStream,
			},
			body = value,
		)

	def do_POST(self):
		key = self.parse_storage_key()
		if not key:
			return

		if not self.sanitize_request_headers({
			HttpHeader.Host,
			HttpHeader.ContentType,
			HttpHeader.ContentLength,
		}):
			return

		try:
			contentLength = int(self.headers[HttpHeader.ContentLength])
		except ValueError:
			self.send_error(
				HTTPStatus.BAD_REQUEST,
				message = HTTPStatus.BAD_REQUEST,
				explain = '"%s" is not a valid value for the HTTP "%s" header.' % (
					self.headers[HttpHeader.ContentLength],
					HttpHeader.ContentLength
				)
			)
			return

		value = self.rfile.read(contentLength)
		self.server.db.insert_or_replace(key, value)

		self.send_ok()

	def do_DELETE(self):
		key = self.parse_storage_key()
		if not key:
			return

		if not self.sanitize_request_headers({HttpHeader.Host}):
			return

		self.server.db.remove(key)

		self.send_ok()

def main():
	binpath = os.path.split(sys.argv[0])[0]
	keyfile = os.path.join(binpath, 'key.pem')
	crtfile = os.path.join(binpath, 'crt.pem')

	parser = argparse.ArgumentParser()
	parser.add_argument(
		'-t', '--test',
		help = 'Run unit tests. Additional arguments are available. If this option is set, it has to be the first.',
		action = 'store_true',
		default = False,
	)
	parser.add_argument(
		'-p', '--port',
		help = 'The port the server should listen on.',
		type = int,
		default = 8080,
	)
	parser.add_argument(
		'-a', '--address',
		help = 'The address the server should listen on.',
		type = str,
		default = '',
	)
	parser.add_argument(
		'-k', '--keyfile',
		help = 'The file containing the private key for SSL connections in PEM format.',
		type = str,
		default = keyfile,
	)
	parser.add_argument(
		'-c', '--certfile',
		help = 'The file containing the certificate for SSL connections in PEM format.',
		type = str,
		default = crtfile,
	)
	parser.add_argument(
		'--allow-superfluous-headers',
		help = 'When set additional HTTP headers will be ignored. A request with additional headers will be rejected else.',
		action = 'store_true',
		default = False,
	)
	parser.add_argument(
		'--enable-test-vectors',
		help = 'Activates test vectors.',
		action = 'store_true',
		default = False,
	)
	args = parser.parse_args()

	if args.test:
		parser.print_help()
		exit(1)

	keyfile = args.keyfile
	crtfile = args.certfile

	serverAddress = (args.address, args.port)

	if not os.path.isfile(keyfile):
		fatal('Missing file: %s' % keyfile)
	if not os.path.isfile(crtfile):
		fatal('Missing file: %s' % crtfile)

	try:
		httpd = http.server.HTTPServer(serverAddress, PServiceRequestHandler)
	except PermissionError:
		fatal('Permission denied. Maybe you need root access to open port %d?' % serverAddress[1])

	httpd.allow_superfluous_headers = args.allow_superfluous_headers

	httpd.db = Database(file_name = 'data.db')

	if args.enable_test_vectors:
		httpd.db.load_test_vectors(file_name = 'test_vectors.json')

	context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
	context.options |= ssl.OP_NO_SSLv2
	context.options |= ssl.OP_NO_SSLv3
	context.options |= ssl.OP_NO_TLSv1
	context.options |= ssl.OP_NO_TLSv1_1
	context.load_cert_chain(
		certfile = crtfile,
		keyfile  = keyfile,
	)

	httpd.socket = context.wrap_socket(
		httpd.socket,
		server_side = True,
	)
	print('Listening on port %d... press ^C to quit.' % serverAddress[1])
	try:
		httpd.serve_forever()
	except KeyboardInterrupt:
		httpd.shutdown()
	print('Done.')

class TestRegularExpressions(unittest.TestCase):

	def test_storage_v1_rx(self):
		# Positive test
		m = STORAGE_V1_RX.match('/storage/v1/ed5d0909f2c385b92166ae74aa6945cdd4d01c3b746ff7c90b93c5725078fc76')
		self.assertIsNotNone(m)
		self.assertEqual(
			m.group(STORAGE_V1_RX_KEY_IDX),
			'ed5d0909f2c385b92166ae74aa6945cdd4d01c3b746ff7c90b93c5725078fc76'
		)

		# Negative tests
		self.assertIsNone(STORAGE_V1_RX.match('/storage/v1/ed5d0909f2c385b92166ae74aa6945cdd4d01c3b746ff7c90b9'))
		self.assertIsNone(STORAGE_V1_RX.match('/storage/v1/ed5d0909f2c385b92166ae74aa6945cdd4d01c3b746ff7c90b93c'))
		self.assertIsNone(STORAGE_V1_RX.match('/storage/v1/ed5d0909f2c385b92166ae74aa6945cdd4d01c3b746ff7c90b9x'))
		self.assertIsNone(STORAGE_V1_RX.match('/storage/v2/ed5d0909f2c385b92166ae74aa6945cdd4d01c3b746ff7c90b93'))
		self.assertIsNone(STORAGE_V1_RX.match('/storaage/v1/ed5d0909f2c385b92166ae74aa6945cdd4d01c3b746ff7c90b93'))

	def test_database(self):
		test_db_file = os.path.join(tempfile.gettempdir(), str(uuid.uuid4()) + ".db")

		db = Database(file_name = test_db_file)

		key = 'ed5d0909f2c385b92166ae74aa6945cdd4d01c3b746ff7c90b93c5725078fc76'

		# Try retrieving non-existant value
		self.assertIsNone(db.value_for(key))

		# Test insertion
		db.insert_or_replace(key, b'foo')
		self.assertEqual(db.value_for(key), b'foo')

		# Test overwriting
		db.insert_or_replace(key, b'bar')
		self.assertEqual(db.value_for(key), b'bar')

		# Test deletion
		db.remove(key)
		self.assertIsNone(db.value_for(key))

		# Cleanup
		del db
		os.remove(test_db_file)

if __name__ == '__main__':
	if len(sys.argv) > 1 and sys.argv[1] in ['-t', '--test']:
		del sys.argv[1]
		unittest.main()
	else:
		main()
